pub mod ess;

use anyhow::Result;
use clap::{Parser, Subcommand};
use ess::EssBuilder;
use log::{Metadata, Record};
use serde::{Deserialize, Serialize};

struct SimpleLogger {}

impl log::Log for SimpleLogger {
    fn enabled(&self, _: &Metadata) -> bool {
        true
    }

    fn log(&self, record: &Record) {
        if self.enabled(record.metadata()) {
            println!("{}", record.args());
        }
    }

    fn flush(&self) {}
}

fn default_name() -> String {
    "noname".to_string()
}

#[derive(clap::Parser, Deserialize, Serialize)]
pub struct User {
    /// The unique user name
    #[clap(long, short)]
    pub username: String,
    /// The user's first name
    #[clap(long, short, default_value_t = String::from("noname"))]
    #[serde(rename = "firstName", default = "default_name")]
    pub first_name: String,
    /// The user's last name
    #[clap(long, short, default_value_t = String::from("noname"))]
    #[serde(rename = "lastName", default = "default_name")]
    pub last_name: String,
}

#[derive(clap::Parser, Deserialize, Serialize)]
#[clap(group(
    clap::ArgGroup::new("update-group")
        .multiple(true)
        .args(&["first-name", "last-name"]),
))]
pub struct UserUpdate {
    /// The user's first name
    #[clap(long, short)]
    #[serde(rename = "firstName", default)]
    first_name: Option<String>,
    /// The user's last name
    #[clap(long, short)]
    #[serde(rename = "lastName", default)]
    last_name: Option<String>,
}

fn default_url(admin: bool) -> String {
    match std::env::var("ESS_WS_URL") {
        Ok(url) => url,
        _ => format!("https://ess.local:{}", if admin { 8081 } else { 8080 }),
    }
}

fn default_root_ca_file(admin: bool) -> String {
    match std::env::var(if admin {
        "ESS_ADMIN_ROOT_CA"
    } else {
        "ESS_PAM_ROOT_CA"
    }) {
        Ok(url) => url,
        _ => format!(
            "./certs/{0}/{0}-root-ca.crt",
            if admin { "admin" } else { "pam" }
        ),
    }
}

fn default_admin_cert_file(admin: bool) -> String {
    match std::env::var(if admin {
        "ESS_ADMIN_CERT"
    } else {
        "ESS_PAM_CERT"
    }) {
        Ok(url) => url,
        _ => format!(
            "./certs/{0}/{0}-client-crt.pem",
            if admin { "admin" } else { "pam" }
        ),
    }
}

fn default_admin_cert_key_file(admin: bool) -> String {
    match std::env::var(if admin {
        "ESS_ADMIN_CERT_KEY"
    } else {
        "ESS_PAM_CERT_KEY"
    }) {
        Ok(url) => url,
        _ => format!(
            "./certs/{0}/{0}-client-key.pem",
            if admin { "admin" } else { "pam" }
        ),
    }
}

#[derive(clap::Parser)]
pub struct ConnectionDetails {
    /// This flag controls if we need to connect as PAM user. By default the admin connection details will be used.
    #[clap(long)]
    pub is_pam: bool,
    /// The webservice host url
    /// To skip this required args set ESS_WS_URL envar
    #[clap(long, default_value_t = default_url(true))]
    pub url: String,
    /// Root CA file path
    /// To skip this required args set ESS_ROOT_CA envar
    #[clap(long, default_value_t = default_root_ca_file(true))]
    pub cafile: String,
    /// The admin client certificate file path
    /// To skip this required args set ESS_ADMIN_CERT envar
    #[clap(long, default_value_t = default_admin_cert_file(true))]
    pub cert: String,
    /// The admin client certificate private key file path
    /// To skip this required args set ESS_ADMIN_CERT_KEY envar
    #[clap(long, default_value_t = default_admin_cert_key_file(true))]
    pub key: String,
}

#[derive(Subcommand)]
pub enum UserAction {
    /// Insert user
    Add {
        /// The user info
        #[clap(flatten)]
        user: User,
        /// Return plain secret code or as QR code
        #[clap(long, short)]
        qr_code: bool,
    },
    /// Update user info & secret except the username
    Update {
        /// The unique user name
        username: String,
        /// The user data to update
        #[clap(flatten)]
        user_data: UserUpdate,
    },
    /// Verify secret for username
    Verify {
        /// The unique user name
        username: String,
        /// The OTP code generated by the app
        one_time_password: String,
    },
    /// Delete user
    Delete {
        /// The unique username
        username: String,
    },
    /// Get user data by username
    GetUser {
        /// The unique username
        username: String,
    },
    /// Get all users
    GetAll,
}

#[derive(Parser)]
#[clap(author, version, about, long_about = None)]
#[clap(propagate_version = false)]
pub struct Cli {
    #[clap(subcommand)]
    /// The user action
    action: UserAction,
    /// The connection details
    #[clap(flatten)]
    conn: ConnectionDetails,
    /// Verbose mode
    #[clap(short, long)]
    verbose: bool,
}

#[tokio::main]
async fn main() -> Result<()> {
    static LOGGER: SimpleLogger = SimpleLogger {};
    log::set_logger(&LOGGER).map_err(|e| anyhow::anyhow!("Failed to set logger: {}", e))?;

    let cli = Cli::parse();

    log::set_max_level(if cli.verbose {
        log::LevelFilter::Trace
    } else {
        log::LevelFilter::Info
    });

    let client = EssBuilder::new(cli.conn).build()?;

    match cli.action {
        UserAction::Add { user, qr_code } => {
            println!(
                "User created with secret: \n{}",
                client.add_user(user, qr_code).await?
            );
        }
        UserAction::Update {
            username,
            user_data,
        } => {
            client.update_user(&username, user_data).await?;
            println!("Username {} data updated successfully", username);
        }
        UserAction::Delete { username } => {
            client.delete_user(&username).await?;
            println!("Username {} deleted successfully", username);
        }
        UserAction::Verify {
            username,
            one_time_password,
        } => {
            client.verify_user(&username, &one_time_password).await?;
            println!("code is OK");
        }
        UserAction::GetUser { username } => {
            println!("User: \n{}", client.get_user(&username).await?);
        }
        UserAction::GetAll => {
            println!("All users: \n{}", client.get_user("all").await?);
        }
    }

    Ok(())
}
